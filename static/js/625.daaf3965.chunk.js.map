{"version":3,"file":"static/js/625.daaf3965.chunk.js","mappings":"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","sources":["lib/puzzleSolver.worker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\n\n// puzzleSolver.worker.js\n\n// Cache for piece orientations\nconst orientationsCache = new Map();\n\nconst getAllOrientations = (coords) => {\n    const cacheKey = coords.map(coord => coord.join(',')).join('|');\n    \n    if (orientationsCache.has(cacheKey)) {\n        return orientationsCache.get(cacheKey);\n    }\n\n    const orientations = new Set();\n    const normalize = (coords) => {\n        const minRow = Math.min(...coords.map(([r]) => r));\n        const minCol = Math.min(...coords.map(([, c]) => c));\n        return coords.map(([r, c]) => [r - minRow, c - minCol]);\n    };\n\n    const coordsToString = (coords) => normalize(coords)\n        .sort(([r1, c1], [r2, c2]) => r1 - r2 || c1 - c2)\n        .map(coord => coord.join(','))\n        .join('|');\n\n    let current = [...coords];\n    for (let flip = 0; flip < 2; flip++) {\n        for (let rot = 0; rot < 4; rot++) {\n            orientations.add(coordsToString(current));\n            current = current.map(([r, c]) => [-c, r]);\n        }\n        current = current.map(([r, c]) => [r, -c]);\n    }\n\n    const result = Array.from(orientations).map(str => \n        str.split('|').map(coord => coord.split(',').map(Number))\n    );\n    \n    orientationsCache.set(cacheKey, result);\n    return result;\n};\n\n// Check if two boards are equal\nconst areBoardsEqual = (board1, board2) => {\n    return board1.every((row, i) => \n        row.every((cell, j) => cell === board2[i][j])\n    );\n};\n\n// Check if a solution is unique\nconst isUniqueSolution = (newSolution, existingSolutions) => {\n    return !existingSolutions.some(solution => \n        areBoardsEqual(newSolution, solution)\n    );\n};\n\n// Check if piece can be placed\nconst canPlacePiece = (board, coords, startRow, startCol) => {\n    const boardHeight = board.length;\n    const boardWidth = board[0].length;\n    \n    for (const [row, col] of coords) {\n        const newRow = startRow + row;\n        const newCol = startCol + col;\n        \n        if (newRow < 0 || newRow >= boardHeight || \n            newCol < 0 || newCol >= boardWidth || \n            board[newRow][newCol] !== \"\") {\n            return false;\n        }\n    }\n    return true;\n};\n\n// Place piece on board\nconst placePiece = (board, piece, coords, startRow, startCol) => {\n    const newBoard = board.map(row => [...row]);\n    coords.forEach(([row, col]) => {\n        newBoard[startRow + row][startCol + col] = piece.symbol;\n    });\n    return newBoard;\n};\n\n// Find next empty position\nconst findEmptyPosition = (board) => {\n    for (let row = 0; row < board.length; row++) {\n        for (let col = 0; col < board[0].length; col++) {\n            if (board[row][col] === \"\") {\n                return [row, col];\n            }\n        }\n    }\n    return null;\n};\n\n// Count empty cells\nconst countEmptyCells = (board) => {\n    return board.reduce((count, row) => \n        count + row.filter(cell => cell === \"\").length, 0\n    );\n};\n\n// Verify if the current board state can lead to a solution\nconst isValidPartialSolution = (board, unusedPieces) => {\n    const emptyCells = countEmptyCells(board);\n    const remainingCells = unusedPieces.reduce((sum, piece) => \n        sum + piece.coords.length, 0\n    );\n    return emptyCells === remainingCells;\n};\n\nlet solutionsFound = 0;\n\nconst solveBoard = (board, unusedPieces, solutions, maxSolutions = 50) => {\n    // Check if we've found enough solutions\n    if (solutionsFound >= maxSolutions) {\n        return true;\n    }\n\n    // Base case: all pieces placed successfully\n    if (unusedPieces.length === 0) {\n        const newSolution = board.map(row => [...row]);\n        if (isUniqueSolution(newSolution, solutions)) {\n            solutions.push(newSolution);\n            solutionsFound++;\n            // Send progress update with current solution\n            self.postMessage({\n                type: 'progress',\n                progress: (solutionsFound / maxSolutions) * 100,\n                currentSolutions: solutions.length\n            });\n        }\n        return false; // searching for more solutions\n    }\n\n    // Quick validation of partial solution\n    if (!isValidPartialSolution(board, unusedPieces)) {\n        return false;\n    }\n\n    const emptyPos = findEmptyPosition(board);\n    if (!emptyPos) return false;\n\n    const [startRow, startCol] = emptyPos;\n\n    // Each piece in each orientation\n    for (let i = 0; i < unusedPieces.length; i++) {\n        const currentPiece = unusedPieces[i];\n        const orientations = getAllOrientations(currentPiece.coords);\n\n        for (const orientation of orientations) {\n            if (canPlacePiece(board, orientation, startRow, startCol)) {\n                const newBoard = placePiece(board, currentPiece, orientation, startRow, startCol);\n                const remainingPieces = [\n                    ...unusedPieces.slice(0, i),\n                    ...unusedPieces.slice(i + 1)\n                ];\n\n                solveBoard(newBoard, remainingPieces, solutions, maxSolutions);\n                \n                if (solutionsFound >= maxSolutions) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\nconst findSolutions = (board, pieces) => {\n    // Reset solution counter\n    solutionsFound = 0;\n    \n    // Get pieces that haven't been placed yet\n    const unusedPieces = pieces.filter(piece => \n        !board.some(row => row.includes(piece.symbol))\n    );\n    \n    // Initialize \n    const solutions = [];\n    \n    // Start solving\n    solveBoard(board, unusedPieces, solutions);\n    \n    return solutions;\n};\n\n// Web Worker message handler\nself.addEventListener('message', (e) => {\n    const { board, pieces } = e.data;\n    try {\n        const solutions = findSolutions(board, pieces);\n        if (solutions.length > 0) {\n            self.postMessage({ \n                success: true, \n                solutions,\n                message: `Found ${solutions.length} solutions!`\n            });\n        } else {\n            self.postMessage({ \n                success: false, \n                error: \"No solutions found!\"\n            });\n        }\n    } catch (error) {\n        self.postMessage({ \n            success: false, \n            error: error.message || \"An error occurred while solving the puzzle.\"\n        });\n    }\n});"],"names":["orientationsCache","Map","getAllOrientations","coords","cacheKey","map","coord","join","has","get","orientations","Set","coordsToString","minRow","Math","min","_ref","r","minCol","_ref2","c","_ref3","normalize","sort","_ref4","_ref5","r1","c1","r2","c2","current","flip","rot","add","_ref6","_ref7","result","Array","from","str","split","Number","set","canPlacePiece","board","startRow","startCol","boardHeight","length","boardWidth","row","col","newRow","newCol","placePiece","piece","newBoard","forEach","_ref8","symbol","solutionsFound","solveBoard","unusedPieces","solutions","maxSolutions","arguments","undefined","newSolution","isUniqueSolution","existingSolutions","some","solution","areBoardsEqual","board2","every","i","cell","j","push","self","postMessage","type","progress","currentSolutions","isValidPartialSolution","emptyCells","reduce","count","filter","countEmptyCells","sum","emptyPos","findEmptyPosition","currentPiece","orientation","remainingPieces","slice","addEventListener","e","pieces","data","findSolutions","includes","success","message","error"],"sourceRoot":""}