{"version":3,"file":"static/js/625.6a8726b8.chunk.js","mappings":"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","sources":["lib/puzzleSolver.worker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\n\n// Explicitly declare worker context\nconst ctx = self;\n\n// unique orientations \nconst getAllOrientations = (coords) => {\n    const orientations = new Set();\n    \n    // Get bounding box to normalize rotations\n    const getBounds = (coords) => {\n        const rows = coords.map(([r]) => r);\n        const cols = coords.map(([, c]) => c);\n        return {\n            minRow: Math.min(...rows),\n            maxRow: Math.max(...rows),\n            minCol: Math.min(...cols),\n            maxCol: Math.max(...cols)\n        };\n    };\n\n    const normalize = (coords) => {\n        const { minRow, minCol } = getBounds(coords);\n        return coords.map(([r, c]) => [r - minRow, c - minCol]);\n    };\n\n    // coordinates to a unique string for Set storage\n    const coordsToString = (coords) => {\n        return normalize(coords)\n            .sort(([r1, c1], [r2, c2]) => r1 - r2 || c1 - c2)\n            .map(coord => coord.join(','))\n            .join('|');\n    };\n\n    // Original orientation\n    let current = [...coords];\n    for (let flip = 0; flip < 2; flip++) {\n        for (let rot = 0; rot < 4; rot++) {\n            orientations.add(coordsToString(current));\n            current = current.map(([r, c]) => [-c, r]); // 90-degree rotation\n        }\n        current = current.map(([r, c]) => [r, -c]); // Flip horizontally\n    }\n\n    // Convert orientations back to arrays\n    return Array.from(orientations).map(str =>\n        str.split('|').map(coord => coord.split(',').map(Number))\n    );\n};\n\n// if a piece can fit on the board at the specified position\nconst canPlacePiece = (board, coords, startRow, startCol) => {\n    const boardHeight = board.length;\n    const boardWidth = board[0].length;\n    \n    for (const [row, col] of coords) {\n        const newRow = startRow + row;\n        const newCol = startCol + col;\n        \n        if (newRow < 0 || newRow >= boardHeight || \n            newCol < 0 || newCol >= boardWidth || \n            board[newRow][newCol] !== \"\") {\n            return false; // Blocked or out of bounds\n        }\n    }\n    return true;\n};\n\n// Places a piece on the board at a given position\nconst placePiece = (board, piece, coords, startRow, startCol) => {\n    const newBoard = board.map(row => [...row]); // Copy board\n    \n    coords.forEach(([row, col]) => {\n        newBoard[startRow + row][startCol + col] = piece.symbol;\n    });\n    \n    return newBoard;\n};\n\n// Finds the next empty cell \nconst findEmptyPosition = (board) => {\n    for (let row = 0; row < board.length; row++) {\n        for (let col = 0; col < board[0].length; col++) {\n            if (board[row][col] === \"\") return [row, col];\n        }\n    }\n    return null; \n};\n\n// Recursive backtracking algorithm to find a solution\nconst solveBoard = (board, unusedPieces, solutions = [], maxSolutions = 1) => {\n    if (unusedPieces.length === 0) {\n        solutions.push(board.map(row => [...row])); // Found solution\n        return solutions.length >= maxSolutions;\n    }\n\n    const emptyPos = findEmptyPosition(board);\n    if (!emptyPos) return false;\n    \n    const [startRow, startCol] = emptyPos;\n\n    for (let i = 0; i < unusedPieces.length; i++) {\n        const piece = unusedPieces[i];\n        const orientations = getAllOrientations(piece.coords);\n        \n        for (const orientation of orientations) {\n            if (canPlacePiece(board, orientation, startRow, startCol)) {\n                const newBoard = placePiece(board, piece, orientation, startRow, startCol);\n                const remainingPieces = [...unusedPieces.slice(0, i), ...unusedPieces.slice(i + 1)];\n                \n                if (solveBoard(newBoard, remainingPieces, solutions, maxSolutions)) {\n                    return true; // Solution found\n                }\n            }\n        }\n    }\n    \n    return false; // No solution with current arrangement\n};\n\n// Entry function for finding the solution\nconst findSolution = (board, pieces) => {\n    const unusedPieces = pieces.filter(piece => \n        !board.some(row => row.includes(piece.symbol))\n    );\n    \n    const solutions = [];\n    solveBoard(board, unusedPieces, solutions, 1);\n    return solutions[0] || null;\n};\n\n// Web Worker message handler\nctx.addEventListener('message', (e) => {\n    const { board, pieces } = e.data;\n    try {\n        const solution = findSolution(board, pieces);\n        ctx.postMessage({ success: true, solution });\n    } catch (error) {\n        ctx.postMessage({ success: false, error: error.message });\n    }\n});\n"],"names":["ctx","self","getAllOrientations","coords","orientations","Set","normalize","minRow","minCol","rows","map","_ref","r","cols","_ref2","c","Math","min","maxRow","max","maxCol","getBounds","_ref3","coordsToString","sort","_ref4","_ref5","r1","c1","r2","c2","coord","join","current","flip","rot","add","_ref6","_ref7","Array","from","str","split","Number","canPlacePiece","board","startRow","startCol","boardHeight","length","boardWidth","row","col","newRow","newCol","placePiece","piece","newBoard","forEach","_ref8","symbol","solveBoard","unusedPieces","solutions","arguments","undefined","maxSolutions","push","emptyPos","findEmptyPosition","i","orientation","remainingPieces","slice","addEventListener","e","pieces","data","solution","findSolution","filter","some","includes","postMessage","success","error","message"],"sourceRoot":""}